clear;
J = @(x,h,F)(F(repmat(x,size(x'))+diag(h))-F(repmat(x,size(x'))))./h';
load guess.mat 

%% Test Open Loop
x0 = [-pi/2; 0; 0; 0];

t_control = linspace(0,10,100);
ut = (t_control>=1)*0.2;

model = 'OpenLoop';

set_param(model, 'SimulationMode', 'normal')
set_param(model, 'SimulationCommand', 'connect')
pause(1)
set_param(model, 'SimulationCommand', 'start')
pause(11)


%% animate result

output = out.pendPos;
ap.l1 = 1;
ap.l2 = 1.5;
for i = 1:50:length(output.time)
    clf; hold on;
    animate(output.time(i), output.signals.values(:,:,i), ap)

    drawnow; pause(0.05); 
end

% 



%% Stabilize Downward
c.bounds = [-4*pi/3 -2*pi/3; -pi/3 pi/3];
c.x_star = [-pi/2; 0; 0; 0];

A = J([-pi/2; 0; 0; 0], 1e-5*ones(1,4), @(x)dynamics(x,0,p));
B = J(0, 1e-5, @(u)dynamics([-pi/2; 0; 0; 0], u, p));

Q = eye(4);
R = 1e-3;

sys = c2d(ss(A,B,eye(4), 0), 0.001);

c.K = lqr(sys, Q, R);

x0 = [0;0;0;0];

%%
model = 'ClosedLoop';
set_param(model, 'Dirty', 'on')

set_param(model, 'SimulationMode', 'normal')
set_param(model, 'SimulationCommand', 'connect')
pause(1)
set_param(model, 'SimulationCommand', 'start')
pause(11)

%% animate result

output = out.pendPos;
ap.l1 = 1;
ap.l2 = 1.5;
for i = 1:50:length(output.time)
    clf; hold on;
    animate(output.time(i), output.signals.values(:,:,i), ap)

    drawnow; pause(0.05); 
end

%% Trajectory Optimization

addpath ../OptimTraj/

problem.func.dynamics = @(t,x,u)( dynamics(x,u,p) );
problem.func.pathObj = @(t,x,u)( u.^2 );

% Problem bounds
problem.bounds.initialTime.low = 0;
problem.bounds.initialTime.upp = 0;
problem.bounds.finalTime.low = 5;
problem.bounds.finalTime.upp = 30;

problem.bounds.state.low = [-inf; -inf; -inf; -inf];
problem.bounds.state.upp = [inf; inf; inf; inf];
problem.bounds.initialState.low = [-pi/2;0;0;0];
problem.bounds.initialState.upp = [-pi/2;0;0;0];
problem.bounds.finalState.low = [pi/2;0;0;0];
problem.bounds.finalState.upp = [pi/2;0;0;0];

problem.bounds.control.low = -inf; %-inf;
problem.bounds.control.upp = inf;

% Guess at the initial trajectory



problem.guess = guess;

% problem.guess.time = [0,25];
% problem.guess.state = [-0.5, 0.5; 0, 0];
% problem.guess.control = [0,0];

% t = linspace(0,20,20);
% problem.guess.time = t;
% problem.guess.state = [t.*sin(t*pi/40*9)/20-0.5; 0, diff(t.*sin(t*pi/40*9)/20-0.5)];
% problem.guess.control = [1, diff(problem.guess.state(2,:))];


% Select a solver:
problem.options.method = 'trapezoid';
problem.options.defaultAccuracy = 'high';
problem.options.trapezoid.nGrid = 100;
% problem.options.nlpOpt = optimoptions('fmincon');
% problem.options.nlpOpt.MaxIterations = 1000;

% Solve the problem
soln = optimTraj(problem);
t = soln.grid.time;
q1 = soln.grid.state(1,:);
q2 = soln.grid.state(2,:);

dq1 = soln.grid.state(3,:);
dq2 = soln.grid.state(4,:);
u = soln.grid.control;

%% plot traj

figure(1); clf;

subplot(3,1,1)
plot(t,q1, t, q2)
legend()
ylabel('q')
title('Pendulum');

subplot(3,1,2)
plot(t,dq1, t, dq2)
legend()
ylabel('dq')

subplot(3,1,3)
plot(t,u)
legend()
ylabel('u')
%%
figure(3)
clf 

hold on 
set(gca, 'YTickLabel', [ ]); 
lblTime = uicontrol('style','text');
lblAction = uicontrol('style','text');
set(lblTime,'Position', [10 20 40 20]);
set(lblAction,'Position', [10 50 40 20]);


for i = 1:length(t)
    clf; hold on;
    animate(t(i), soln.grid.state(:,i), ap)


    % set(lblTime,'String', i - 1);
    % set(lblAction,'String', u(i));
    
    drawnow;
    pause(0.05);
end

%% Test Open Loop With Simulink

x0 = [-pi/2; 0; 0; 0];

t_control = t;
ut = u;

model = 'OpenLoop';

set_param(model, "StopTime", )
set_param(model, 'SimulationMode', 'normal')
set_param(model, 'SimulationCommand', 'connect')
pause(1)
set_param(model, 'SimulationCommand', 'start')
pause(11)


%% animate result

output = out.pendPos;
ap.l1 = 1;
ap.l2 = 1.5;
for i = 1:50:length(output.time)
    clf; hold on;
    animate(output.time(i), output.signals.values(:,:,i), ap)

    drawnow; pause(0.05); 
end

% 